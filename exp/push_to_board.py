
#################################################
### THIS FILE WAS AUTOGENERATED! DO NOT EDIT! ###
#################################################
# file to edit: dev_nb/02_push_to_postings.ipynb

from datetime import date, timedelta
from pymongo import MongoClient
import numpy as np # best match
import pandas as pd

# compare distances between sequence of words
def levenshtein_ratio_and_distance(s, t):
    """ levenshtein_ratio_and_distance:
        Calculates levenshtein distance between two strings.
        If ratio_calc = True, the function computes the
        levenshtein distance ratio of similarity between two strings
        For all i and j, distance[i,j] will contain the Levenshtein
        distance between the first i characters of s and the
        first j characters of t
    """
    # Initialize matrix of zeros
    rows = len(s)+1
    cols = len(t)+1
    distance = np.zeros((rows,cols),dtype = int)

    # Populate matrix of zeros with the indeces of each character of both strings
    for i in range(1, rows):
        for k in range(1,cols):
            distance[i][0] = i
            distance[0][k] = k

    # Iterate over the matrix to compute the cost of deletions,insertions and/or substitutions
    for col in range(1, cols):
        for row in range(1, rows):
            if s[row-1] == t[col-1]:
                cost = 0 # If the characters are the same in the two strings in a given position [i,j] then the cost is 0
            else:
                # In order to align the results with those of the Python Levenshtein package, if we choose to calculate the ratio
                # the cost of a substitution is 2. If we calculate just distance, then the cost of a substitution is 1.
                cost = 2
            distance[row][col] = min(distance[row-1][col] + 1,      # Cost of deletions
                                 distance[row][col-1] + 1,          # Cost of insertions
                                 distance[row-1][col-1] + cost)     # Cost of substitutions
    # Computation of the Levenshtein Distance Ratio
    Ratio = ((len(s)+len(t)) - distance[row][col]) / (len(s)+len(t))
    return Ratio

def find_values_(user_input, records):
    """
    mocking out api call. This will retrieve all matching user input without levensthtein
    """
    user_input = user_input[0].upper() + user_input[1:]
    values = records.find({'title': { '$regex': f'^{user_input}' }})
    return list(values)

def find_best_match(user_input, values):
    """
    Will return best matches in a df format
    """
    values_df = pd.DataFrame(values)
    values_df['match_rating'] = values_df['title'].apply(lambda x: levenshtein_ratio_and_distance(x, user_input))
    values_df.sort_values('match_rating', ascending=False, inplace=True)
    return values_df

def post_to_board(matches, postings, amount=10):
    """
    Will post best matches into the boards collection. This will replicate posting into a jobs board.

    amount: <int | string> will determine how many of the matches will be used.
    """
    # condition of amount
    if isinstance(amount, int): matches = matches.head(amount)
    elif isinstance(amount, str) and amount == 'all': matches = matches # all matches
    else: raise ValueError('amount has wrong value')

    # pushing to board
    for i in range(len(matches)):
        job = matches.iloc[i].to_dict()
        job['post_date'] = date.today().strftime('%Y-%m-%d')
        if postings.find_one(job): pass
        else: postings.insert_one(job) # post if it's not there